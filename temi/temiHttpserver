package com.example.temicontrolapp;

// import com.robotemi.sdk.communication.TtsRequest;  // 주석처리 (Temi SDK 연동 후 다시 사용 가능)
import com.robotemi.sdk.Robot;
import java.io.IOException;
import java.net.*;
import java.util.Enumeration;
import fi.iki.elonen.NanoHTTPD;

public class TemiHttpServer extends NanoHTTPD {

    public TemiHttpServer() throws IOException {
        super(8080);
        start(SOCKET_READ_TIMEOUT, false);
        System.out.println("✅ Temi 서버 시작됨: http://192.168.35.173:5555/speak");
    }

    @Override
    public Response serve(IHTTPSession session) {
        String uri = session.getUri();
        System.out.println("📡 요청 받음: " + uri);

        if (uri.equals("/speak")) {
            // Robot.getInstance().speak(TtsRequest.create("외부에서 명령 도착!", false));  // Temi SDK 연동 후 주석 해제 예정
            System.out.println("✅ Temi speak 요청 (현재는 주석처리 상태)");
            return newFixedLengthResponse("Temi가 speak 명령 받음 (현재는 테스트용)");
        } else if (uri.equals("/move")) {
            Robot.getInstance().goTo("home base");
            return newFixedLengthResponse("Temi가 move 명령 받음");
        } else {
            return newFixedLengthResponse("❗ 알 수 없는 명령: " + uri);
        }
    }

    private String getDeviceIpAddress() {
        try {
            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
                NetworkInterface intf = en.nextElement();
                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
                    InetAddress inetAddress = enumIpAddr.nextElement();
                    if (!inetAddress.isLoopbackAddress() && inetAddress instanceof Inet4Address) {
                        return inetAddress.getHostAddress();
                    }
                }
            }
        } catch (SocketException ex) {
            ex.printStackTrace();
        }
        return "localhost";
    }
}



테스트 서버

server.py

import socket
import os
import subprocess
import threading

HOST = '0.0.0.0'
PORT = 12345
BUFFER_SIZE = 1024

def run_chat_script():
    venv_python = os.path.abspath(os.path.join(os.getcwd(), "..", "tts_venv", "Scripts", "python.exe"))
    script_path = os.path.join(os.getcwd(), "realtime_chat_withGPT.py")

    if not os.path.exists(venv_python):
        print(f"❗ Python 실행 파일이 존재하지 않음: {venv_python}")
        return
    if not os.path.exists(script_path):
        print(f"❗ 실행할 스크립트가 존재하지 않음: {script_path}")
        return

    try:
        print("🎬 'realtime_chat_withGPT.py' 실행 중 (비차단)...")
        subprocess.Popen([venv_python, script_path])
    except Exception as e:
        print(f"❗ 'realtime_chat_withGPT.py' 실행 실패: {e}")

def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((HOST, PORT))
    server_socket.listen(5)
    server_socket.settimeout(1.0)

    print(f"✅ 서버 실행 중 (포트 {PORT})")

    try:
        while True:
            print("💤 클라이언트 연결 대기 중...")
            try:
                client_socket, addr = server_socket.accept()
            except socket.timeout:
                continue
            except KeyboardInterrupt:
                raise

            print(f"🔗 클라이언트 연결됨: {addr}")
            client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

            try:
                while True:
                    data = client_socket.recv(BUFFER_SIZE)
                    if not data:
                        print("⚠️ 클라이언트 연결 종료 감지.")
                        break

                    message = data.decode('utf-8').strip()
                    print(f"📨 받은 메시지: {message}")

                    if message == "speak":
                        # 별도 스레드에서 실행하여 서버 멈춤 방지
                        threading.Thread(target=run_chat_script, daemon=True).start()
                        client_socket.sendall("대화 스크립트 실행 시작\n".encode('utf-8'))
                        response = f"서버가 메시지 받음: {message}\n"
                        client_socket.sendall(response.encode('utf-8'))

                    elif message == "move":
                        response = f"도슨트 로봇이 도착했습니다.\n"
                        client_socket.sendall(response.encode('utf-8'))

                    elif message == "exit":
                        print("❌ 클라이언트 종료 요청 받음. 연결 종료.")
                        break

            except Exception as e:
                print(f"❗ 통신 중 오류 발생: {e}")
            finally:
                client_socket.close()
                print("🔄 클라이언트 소켓 닫힘. 다음 연결 대기 중...\n")

    except KeyboardInterrupt:
        print("\n🛑 서버 강제 종료 요청 감지 (Ctrl + C). 서버 소켓 종료합니다.")
    finally:
        server_socket.close()
        print("✅ 서버 종료 완료.")

if __name__ == "__main__":
    main()
